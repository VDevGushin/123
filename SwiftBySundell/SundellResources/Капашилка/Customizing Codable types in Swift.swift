//
//  Customizing Codable types in Swift.swift
//  SwiftBySundell
//
//  Created by Vlad Gushchin on 15/07/2019.
//  Copyright © 2019 Vladislav Gushin. All rights reserved.
//

import Foundation
/*Одна из общих черт большинства современных приложений заключается в том, что им необходимо кодировать или декодировать различные формы данных. Будь то данные JSON, которые были загружены по сети, или некоторая форма сериализованного представления модели, которая хранится локально - возможность надежного кодирования и декодирования различных фрагментов данных важна для более или менее любой базы кода Swift.
 
 Это большая часть того, почему Swift Codable API был такой важной новой функцией, когда он был представлен как часть Swift 4.0 - и с тех пор он стал стандартным надежным механизмом для нескольких различных видов кодирования и декодирования - как на Apple платформы, а также для серверной части Swift.
 
 Что делает Codable таким замечательным, так это то, что он тесно интегрирован в цепочку инструментов Swift, что позволяет компилятору автоматически синтезировать большую часть кода, необходимого для кодирования и декодирования различных значений. Однако иногда нам нужно настроить представление наших значений при сериализации - поэтому на этой неделе давайте рассмотрим несколько разных способов настройки наших Codable-реализаций, чтобы сделать именно это.*/

// MARK: - Changing keys

/*Давайте начнем с одного из основных способов, которыми мы можем настраивать способ кодирования и декодирования типа - путем изменения ключей, которые используются как часть его сериализованного представления. Допустим, мы работаем над приложением для чтения статей, и одна из наших основных моделей данных выглядит следующим образом:*/
fileprivate struct Article: Codable {
    var url: URL
    var title: String
    var body: String
}

/*В настоящее время наша модель использует полностью автоматическую реализацию Codable, что означает, что все ее ключи сериализации будут совпадать с именами ее свойств. Однако данные, из которых мы будем декодировать значения Article, например JSON, загруженные с сервера, могут использовать немного другое соглашение об именах, что приведет к сбою декодирования по умолчанию.
 
 К счастью, это легко исправить. Все, что нам нужно сделать, чтобы настроить, какие ключи будут использовать Codable при декодировании (или кодировании) экземпляров нашего типа Article, - это определить перечисление CodingKeys внутри него - и назначить пользовательские необработанные значения для случаев, соответствующих ключам, которые мы хотим настроить - как это:
*/

extension Article {
    enum CodingKeys: String, CodingKey {
        case url = "source_link"
        case title = "content_name"
        case body
    }
}
/*Выполнение вышеупомянутого позволяет нам продолжать использовать сгенерированную компилятором реализацию по умолчанию для фактической работы над кодированием, в то же время позволяя нам изменять имена ключей, которые будут использоваться для сериализации.
 
 Хотя описанная выше техника отлично подходит для случаев, когда мы хотим использовать полностью настраиваемые имена ключей, если бы мы только хотели, чтобы Codable использовал версии имен наших свойств в snake_case (например, превращение backgroundColor в background_color) - тогда мы могли бы просто изменить keyDecodingStrategy нашего декодера JSON вместо:*/
private func test() {
    let decoder = JSONDecoder()
    decoder.keyDecodingStrategy = .convertFromSnakeCase
}

/*Что хорошо в двух вышеуказанных API-интерфейсах, так это то, что они позволяют нам обойти несоответствия между нашими моделями Swift и данными, которые будут использоваться для их представления, без необходимости изменения имен наших свойств.
*/

// MARK: - Ignoring keys
/*Хотя очень полезно иметь возможность настраивать имена ключей кодирования, иногда нам может потребоваться полностью игнорировать некоторые из них. Например, давайте теперь скажем, что мы работаем над приложением для создания заметок - и что мы даем пользователю возможность группировать различные заметки вместе, чтобы сформировать коллекцию заметок, которая может включать локальные черновики:*/
fileprivate struct Note: Codable { }

fileprivate struct NoteCollection: Codable {
    var name: String
    var notes: [Note]
    var localDrafts = [Note]()
}
/*Однако, хотя очень удобно, чтобы localDrafts были частью нашей модели NoteCollection, допустим, что мы не хотим, чтобы эти черновики были включены при сериализации или десериализации такой коллекции. Причиной этого может быть предоставление пользователю чистого листа при каждом запуске приложения или потому, что наш сервер не поддерживает черновики.
 
 К счастью, это также легко сделать без изменения фактической реализации Codable для NoteCollection. Если мы определим перечисление CodingKeys, как и прежде, и просто опустим localDrafts - тогда это свойство не будет учитываться при кодировании или декодировании значения NoteCollection:*/
extension NoteCollection {
    enum CodingKeys: CodingKey {
        case name
        case notes
    }
}
/*Чтобы вышеприведенное сработало, свойство, которое мы опускаем, должно иметь значение по умолчанию - которое localDrafts уже имело в этом случае.*/

// MARK: - Creating matching structures

/*До сих пор мы только настраивали ключи кодирования типа - и хотя мы часто можем довольно далеко продвинуться, просто делая это, иногда нам нужно пойти немного дальше с точки зрения нашей настройки Codable.
 
 Допустим, мы создаем приложение, которое включает в себя функцию конвертации валют, и что мы загружаем текущие курсы обмена для данной валюты в виде данных JSON, который выглядит следующим образом:*/
/*
{
    "currency": "PLN",
    "rates": {
        "USD": 3.76,
        "EUR": 4.24,
        "SEK": 0.41
    }
}
*/
/*Затем в нашем Swift-коде мы хотим преобразовать такие ответы JSON в экземпляры преобразования валюты, каждый из которых содержит массив записей обменного курса, по одному для каждой валюты:*/

fileprivate typealias Currency = String

fileprivate struct CurrencyConversionOld {
    var currency: Currency
    var exchangeRates: [ExchangeRate]
}

fileprivate struct ExchangeRate {
    let currency: Currency
    let rate: Double
}

/*Однако, если мы просто сделаем так, чтобы обе вышеуказанные модели соответствовали Codable, мы снова получили бы несоответствие между нашим кодом Swift и данными JSON, которые мы ищем для декодирования. Но на этот раз дело не только в ключевых именах - здесь есть принципиальная разница в структуре.
 
 Конечно, мы могли бы изменить структуру наших моделей Swift, чтобы они точно соответствовали структуре наших данных JSON, но это не всегда практично. Хотя наличие правильного кода сериализации важно, наличие структуры модели, которая соответствует нашей фактической базе кода, возможно, столь же важно.
 
 Вместо этого давайте создадим новый выделенный тип, который будет служить мостом между форматом, используемым в наших данных JSON, и структурой нашего кода Swift. В этом типе мы сможем инкапсулировать всю логику, необходимую для преобразования словаря обменных курсов JSON в массив моделей ExchangeRate, например:
*/

private extension ExchangeRate {
    struct List: Decodable {
        let values: [ExchangeRate]

        init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            let dictionary = try container.decode([String: Double].self)

            self.values = dictionary.map { key, value in
                ExchangeRate(currency: key, rate: value)
            }
        }
    }
}

/*Используя приведенный выше тип, мы теперь можем определить частное свойство, имя которого совпадает с ключом JSON, используемым для его данных, и сделать так, чтобы наше свойство exchangeRates просто действовало как открытый прокси для этого частного свойства:*/
fileprivate struct CurrencyConversion: Decodable {
    var currency: Currency

    var exchangeRates: [ExchangeRate] {
        return rates.values
    }

    private var rates: ExchangeRate.List
}

// MARK: - Transforming values
/*При декодировании, особенно при работе с внешними API-интерфейсами JSON, которые находятся вне нашего контроля, очень часто возникает проблема, когда типы кодируются способом, который несовместим с системой строгих типов Swift. Например, данные JSON, которые мы ищем для декодирования, могут использовать строки для представления целых чисел или других чисел.
 
 Давайте рассмотрим способ, с помощью которого мы можем иметь дело с такими значениями, опять же автономным способом, который не требует от нас написания полностью настраиваемой реализации Codable.
 
 В сущности, мы хотим преобразовать строковые значения в другой тип - давайте возьмем Int в качестве примера. Мы начнем с определения протокола, который позволит нам пометить любой тип как StringRepresentable - это означает, что он может быть преобразован из строкового представления и в него:*/

fileprivate protocol StringRepresentable: CustomStringConvertible {
    init?(_ string: String)
}

extension Int: StringRepresentable { }

/*
 Мы основываем наш вышеупомянутый протокол на CustomStringConvertible из стандартной библиотеки, поскольку он уже включает требование к свойству для описания значения в виде строки. Чтобы узнать больше об этом способе определения протоколов как специализаций других, ознакомьтесь с разделом «Специализированные протоколы в Swift».
 
 Далее, давайте создадим еще один выделенный тип - на этот раз для любого значения, которое может быть подкреплено строкой - и пусть он содержит весь код, необходимый для декодирования и кодирования значения в строку и из нее:
 */

fileprivate struct StringBacked<Value: StringRepresentable>: Codable {
    var value: Value

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let string = try container.decode(String.self)

        guard let value = Value(string) else {
            throw DecodingError.dataCorruptedError(
                in: container,
                debugDescription: """
                Failed to convert an instance of \(Value.self) from "\(string)"
                """
            )
        }

        self.value = value
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(value.description)
    }
}
/*Точно так же, как ранее мы создавали частное свойство для нашего JSON-совместимого базового хранилища, теперь мы можем сделать то же самое для любого свойства, которое при кодировании является бэкэндом в виде строки, при этом все же предоставляя эти данные остальной части нашего кода Swift как собственно тип. Вот пример того, как сделать это для свойства numberOfLikes типа Video:*/

fileprivate struct Video: Codable {
    var title: String
    var description: String
    var url: URL
    var thumbnailImageURL: URL

    var numberOfLikes: Int {
        get { return likes.value }
        set { likes.value = newValue }
    }

    private var likes: StringBacked<Int>
}

/*Здесь определенно существует компромисс между сложностью необходимости вручную определять установщики и получатели для свойства и сложностью необходимости использовать полностью настраиваемую реализацию Codable, но для типов, подобных приведенной выше структуре Video, которая имеет только одно свойство в необходимость настройки, использование частного свойства поддержки может быть отличным вариантом.*/
