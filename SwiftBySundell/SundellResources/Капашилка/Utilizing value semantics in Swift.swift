//
//  Utilizing value semantics in Swift.swift
//  SwiftBySundell
//
//  Created by Vlad Gushchin on 29/07/2019.
//  Copyright © 2019 Vladislav Gushin. All rights reserved.
//

import UIKit

// MARK: - Unlocking local mutations

/*
 В общем, чем менее изменчивое состояние содержится в программе, тем меньше вероятность возникновения ошибок. Когда вещи остаются неизменными, они по своей природе более предсказуемы, поскольку нет никаких шансов на неожиданные изменения. Однако создание чего-то неизменного также часто означает жертву гибкости, которая иногда может стать проблематичной.
 
 Допустим, мы работаем над приложением, которое работает с видео, и чтобы сделать нашу базовую модель видео максимально предсказуемой, мы решили сделать все ее свойства неизменяемыми, определив их с помощью let:
 */

fileprivate struct Tag: Hashable {
    let name: String
}

fileprivate struct Video1 {
    let id: UUID
    let url: URL
    let title: String
    let description: String
    let tags: Set<Tag>
}

/*Вышеприведенное может показаться на первый взгляд хорошей идеей, особенно если единственным текущим способом получения экземпляров Video является их декодирование из данных, загруженных по сети. Тем не менее, благодаря силе семантики значения, делать что-то подобное выше часто не нужно.
 
 Структуры не только неизменяемы по умолчанию, если они не хранятся в переменной, которая сама является изменяемой, любые изменения, сделанные в экземпляре структуры, также всегда будут применяться только к локальной копии этого значения. Это означает, что даже если бы мы открыли наш тип видео для мутаций, мы не рискуем вносить ошибки, вызванные необработанными изменениями состояния.
 
 Итак, давайте сделаем это, используя var для определения большинства свойств нашей модели, а не let. Однако мы не будем вносить это изменение во все свойства - поскольку мы хотим, чтобы некоторые из них всегда оставались постоянными - например, id и url в этом случае:*/

fileprivate struct Video2 {
    let id: UUID
    let url: URL
    var title: String
    var description: String
    var tags: Set<Tag>
}

/*Выполнив вышеуказанное изменение, мы оба проясним, какие части модели видео могут измениться в будущем (даже если такие мутации произойдут в другом месте, например на нашем сервере), но мы также разблокируем новые сценарии использования для этой модели - например, используя его для отслеживания местного состояния.
 
 Допустим, мы добавляем новую функцию в наше видео приложение, которое позволяет нашим пользователям выполнять локальное редактирование видео, которое они ранее загрузили. Поскольку теперь мы открыли нашу модель видео для локальных мутаций, мы могли бы просто позволить такому видеоредактору работать непосредственно с экземпляром нашей модели - вот так:*/

fileprivate class VideoEditingViewController: UIViewController {
    private var video: Video2?

    func titleTextFieldDidChange(_ textField: UITextField) {
        textField.text.map { video?.title = $0 }
    }

    func tagSelectionView(_ view: UIView,
        didAddTagNamed tagName: String) {
        video?.tags.insert(Tag(name: tagName))
    }
}

/*Прелесть семантики значений в приведенном выше сценарии заключается в том, что любые локальные мутации, которые VideoEditingViewController создает для своего частного значения Video, не будут распространяться в других местах. Это означает, что мы можем работать с этим значением в полной изоляции, и все пользовательские изменения могут быть четко отделены от исходного источника данных.
 
 С другой стороны, всякий раз, когда мы хотим сохранить какой-либо экземпляр Video полностью неизменным, все, что нам нужно сделать, это сослаться на него с помощью let - и никакие мутации не будут разрешены:*/
fileprivate struct Query {

}

fileprivate struct SearchResult {
    let video: Video2
    let matchedQuery: Query
}
/*Когда речь идет о наших основных моделях данных, таких как приведенный выше тип видео, то разрешающий контекст позволяет решать, разрешать ли мутации или нет - вместо того, чтобы объединять эти решения в каждой модели, - часто делает код нашей модели гораздо более гибким, без каких-либо существенных рисков. , все благодаря семантике значения.*/

// MARK: - Ensuring data consistency
/*Однако иногда нам нужно немного больше контролировать, когда речь заходит о том, как модель может быть видоизменена, особенно если разные части этой модели так или иначе связаны или зависят друг от друга.
 
 Например, давайте теперь скажем, что мы работаем над приложением для покупок, которое содержит модель ShoppingCart. Помимо хранения массива значений Product, добавленных пользователем в корзину, мы также храним общую стоимость всех продуктов и их идентификаторы - чтобы избежать необходимости пересчитывать общую стоимость каждый раз, когда к ней обращаются, и обеспечивать постоянную -время поиска того, был ли данный продукт уже добавлен:*/
fileprivate struct Product {
    let price: Int
    let id: UUID
}
fileprivate struct ShoppingCart {
    var totalPrice: Int
    var productIDs: Set<UUID>
    var products: [Product]
}

/*Приведенная выше настройка дает нам большую гибкость и высокую производительность, поскольку многие из общих операций, которые мы будем выполнять с экземпляром ShoppingCart, могут выполняться за постоянное время - однако в этом случае создание всего изменяемого также создает значительный риск для наши данные становятся противоречивыми.
 
 Мы не только должны всегда помнить об обновлении свойств totalPrice и productIDs всякий раз, когда мы добавляем или удаляем продукт, каждое из этих свойств также может быть изменено в любое время - без каких-либо изменений в продуктах. Это не очень хорошо, но, к счастью, есть решение, которое позволяет нам продолжать использовать семантику значений, но немного более контролируемым образом.
 
 Вместо того чтобы делать каждое свойство полностью изменяемым, давайте ограничим большинство мутаций, которые будут разрешены только внутри самого типа ShoppingCart, с помощью модификатора private (set) access. Затем мы выполним эти мутации только в прямом ответе на изменение в массиве products, используя наблюдатель свойства - вот так:*/

fileprivate struct GoodShoppingCart {
    private(set) var totalPrice = 0
    private(set) var productIDs: Set<UUID> = []

    var products: [Product] {
        didSet { productsDidChange() }
    }

    init(products: [Product]) {
        self.products = products
        productsDidChange()
    }

    private mutating func productsDidChange() {
        totalPrice = products.reduce(0) { price, product in
            price + product.price
        }

        productIDs = []
        products.forEach { productIDs.insert($0.id) }
    }
}

// MARK: - Simplifying repeated mutations
/*Хотя семантика значений дает нам массу преимуществ с точки зрения ограничения того, как и где могут происходить мутации, иногда эти ограничения могут сделать определенные фрагменты кода немного более сложными, чем они должны быть.
 
 Здесь мы работаем над типом, который позволяет нам моделировать конвейер рендеринга изображений как серию операций на основе замыканий, которые применяются к структуре RenderingContext. Каждой операции передается предыдущий контекст в качестве входных данных, происходит его изменение, а затем возвращается обновленное значение в качестве выходных данных. Наконец, когда все операции выполнены, мы берем окончательное значение контекста и используем его для генерации изображения:*/

fileprivate struct RenderingContext {
    private var color: UIColor = .red
    mutating func changeFillColor(to: UIColor) { self.color = to }
    func fill(rect: CGRect) { }
    func makeImage() -> UIImage? {
        return nil
    }
}

fileprivate struct RenderingPipeline {
    var operations: [(RenderingContext) -> RenderingContext]

    func render() -> UIImage? {
        var context = RenderingContext()

        context = operations.reduce(context) { context, operation in
            operation(context)
        }

        return context.makeImage()
    }

    mutating func fill(with color: UIColor) {
        operations.append { context in
            var context = context
            context.changeFillColor(to: color)
            context.fill(rect: CGRect.zero)
            return context
        }
    }
}

/*Вышеприведенное может показаться не таким уж большим делом, и если количество операций, которые мы можем выполнить, будет сведено к минимуму, это, вероятно, не будет. Однако для того, чтобы всегда иметь необходимость копировать и возвращать текущий контекст рендеринга, нам нужно написать довольно много шаблонного примера, поэтому давайте посмотрим, сможем ли мы что-то с этим сделать.
 
 Хотя мы хотим, чтобы RenderingContext оставался структурой, давайте фактически передадим его по ссылке, а не по значению при вызове каждой операции - используя ключевое слово inout. Таким образом, мы можем просто продолжать изменять одно и то же значение контекста по всему нашему конвейеру:
*/

fileprivate struct GoodRenderingPipeline {
    var operations: [(inout RenderingContext) -> Void]

    func render() -> UIImage? {
        var context = RenderingContext()
        operations.forEach { $0(&context) }
        return context.makeImage()
    }

    mutating func fill(with color: UIColor) {
        operations.append { context in
            context.changeFillColor(to: color)
            context.fill(rect: .zero)
        }
    }
}
