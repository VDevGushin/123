//
//  Trimming long argument lists.swift
//  SwiftBySundell
//
//  Created by Vladislav Gushin on 12/02/2019.
//  Copyright © 2019 Vladislav Gushin. All rights reserved.
//

import UIKit

/*Добавление новых функций в приложение или инфраструктуру часто включает добавление новых аргументов в существующие функции.
 Нам может потребоваться новый способ настройки обычной операции или небольшая настройка способа визуализации,
 чтобы иметь возможность интегрировать нашу новую функцию с остальной частью нашей базы кода.
 
 Хотя поначалу большинство таких изменений могут показаться тривиальными, если мы не будем осторожны, мы можем - со временем - в конечном итоге значительно расширить область действия функции или типа, намного превышающую то, для чего она изначально была разработана, - оставив нам API-интерфейсы, которые немного непонятно и громоздко в использовании.
 
 На этой неделе давайте посмотрим, как работать с такими функциями, и как их часто можно упростить, сократив количество аргументов, которые они принимают.*/

// MARK: - Growing pains

/*Давайте начнем с рассмотрения примера. Здесь у нас есть функция, которую мы можем использовать, чтобы легко представить профиль текущего пользователя в нашем приложении - опционально с анимацией:*/

fileprivate func presentProfile(animated: Bool) {
}

/*Достаточно просто. Однако со временем, по мере добавления новых функций в приложение - нам может понадобиться добавить все больше и больше параметров настройки в вышеупомянутую функцию, превращая то, что изначально было очень простым, во что-то гораздо более сложное:*/

func presentProfile(animated: Bool,
                    duration: TimeInterval = 0.3,
                    curve: UIView.AnimationCurve = .easeInOut,
                    completionHandler: (() -> Void)? = nil) {
}

/*Вышеприведенная функция не обязательно плохая (она соответствует большинству современных соглашений по разработке Swift API), но ее становится немного сложно понять, и ей не хватает простоты и элегантности ее оригинальной версии. Здесь также легко увидеть тенденцию - вышеприведенная функция вряд ли перестанет расти, поскольку новые функции также потребуют аналогичных настроек и новых опций.*/

// MARK: - Reducing ambiguity(уменьшение неоднозначности)
fileprivate struct Animation {
    var duration: TimeInterval = 0.3
    var curve = UIView.AnimationCurve.easeInOut
    var completionHandler: (() -> Void)? = nil
}

/*С учетом вышесказанного мы можем свести все предыдущие четыре аргумента к одному, что позволяет вернуться к такой же элегантной и простой сигнатуре функции, как у нас изначально:*/
fileprivate func presentProfile(with animation: Animation? = nil) {
}

// MARK: - Composition
/*Другая распространенная проблема с длинными списками аргументов состоит в том, что мы получаем функции, которые выполняют слишком много задач, что затрудняет чтение и поддержку их реализаций. Например, здесь у нас есть функция, которая загружает список друзей пользователя, соответствующих поисковому запросу, а также включает параметры для сортировки и фильтрации:*/
fileprivate enum Result<T> {
    case error(Error)
    case value(T)
}

fileprivate struct Friend {
    struct Group {

    }
}

fileprivate func loadFriends(matching query: String,
                             limit: Int?,
                             sorted: Bool,
                             filteredByGroup group: Friend.Group?,
                             handler: @escaping (Result<[Friend]>) -> Void) {
}


/*Хотя может быть очень удобно, чтобы одна функция выполняла все, что нам нужно, при загрузке друзей, такие функции часто становятся беспорядочными и ошибочными из-за сложной логики с множеством различных путей кода в зависимости от того, какая комбинация аргументов была передана.
 
 Вместо этого давайте уменьшим область действия loadFriends, чтобы включить только фактическую загрузку друзей, без каких-либо функций сортировки или фильтрации. Таким образом, это может стать проще, проще для тестирования, и мы не дадим ему стать базой сброса кода. Так как сортировка и фильтрация в любом случае очень специфичны для контекста, мы передадим эти операции вызывающим функциям, например так:
 loadFriends(matching: query) { [weak self] result in
 switch result {
 case .success(let friends):
 self?.render(friends.filtered(by: group).sorted())
 case .failure(let error):
 self?.render(error)
 }
 }
 */

// MARK: - Extraction
/*
 Наконец, давайте посмотрим, как мы можем извлечь длинные списки аргументов в новый, выделенный тип. В качестве примера, скажем, у нас есть расширение на UIViewController, которое позволяет нам предоставлять пользователю диалог из любого места в приложении - где пользователь может либо принять, либо отклонить предложение:
*/

fileprivate struct DialogOutcome { }

fileprivate extension UIViewController {
    func presentDialog(withTitle title: String,
                       message: String,
                       acceptTitle: String,
                       rejectTitle: String,
                       handler: @escaping (DialogOutcome) -> Void) {
    }
}

/*Опять же, мы имеем дело с довольно длинным списком аргументов, который, как можно ожидать, будет только расти, поскольку нам может потребоваться представить все более и более сложные диалоги. Хотя мы могли бы реорганизовать вышеприведенное, чтобы использовать несколько расширений UIViewController, это также может со временем запутаться, так как мы наполним UIViewController API множеством диалогов, представляющих функциональность.
 
 Вместо этого давайте попробуем переместить вышеуказанную функциональность в ее собственный, выделенный тип. В этом случае мы создадим структуру с именем DialogPresenter, которая будет содержать свойства для всех параметров, которые ранее были аргументами, например:*/

fileprivate struct DialogPresenter {
    typealias Handler = (DialogOutcome) -> Void

    let title: String
    let message: String
    let acceptTitle: String
    let rejectTitle: String
    let handler: Handler
    
    init(title: String, handler: @escaping Handler) {
        self.title = title
        self.handler = handler
        message = ""
        acceptTitle = "Yes"
        rejectTitle = "No"
    }

    func present(in viewController: UIViewController) {
    }
}
