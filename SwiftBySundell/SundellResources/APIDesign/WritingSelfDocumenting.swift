//
//  WritingSelfDocumenting.swift
//  SwiftBySundell
//
//  Created by Vladislav Gushin on 19/02/2019.
//  Copyright © 2019 Vladislav Gushin. All rights reserved.
//

import UIKit
/*Когда и как писать документацию и комментарии к коду, это то, что вызывает много споров среди разработчиков. Некоторые люди предпочитают, чтобы весь код был тщательно документирован и прокомментирован, чтобы сделать вещи более понятными и простыми в обслуживании, оставляя «бумажный след» того, каково было намерение кода, когда он был написан.
 
 С другой стороны, другие люди чувствуют, что написание документации - пустая трата времени, и на самом деле усложнять ее обслуживание, поскольку комментарии и документация часто устаревают по мере изменения деталей реализации.
 
 Независимо от того, как вы относитесь к написанию (и чтению) документации - я думаю, что большинство из нас согласны с тем, что мы должны всегда стараться сделать наш код и разрабатываемые нами API-интерфейсы как можно более простыми для понимания. Мы все хотим избежать той ситуации, когда мы получим код, который никто в команде не понимает, либо потому, что первоначальные авторы покинули компанию, либо просто потому, что никто не помнит детали того, что код должен был делать изначально.
 
 На этой неделе давайте рассмотрим несколько простых советов и уловок, которые могут позволить нам написать код, который является более самодокументируемым - код, который делает основные намерения и детали более понятными, просто благодаря тому, как он структурирован и как он написан.*/

// MARK: - Breaking things up

/*Системы, которые, как правило, вызывают наибольшую путаницу с течением времени, представляют собой огромные сгустки логики. Чем массивнее и сложнее становятся вещи, тем сложнее их рассуждать. Кроме того, по мере того, как дела растут, в миксе теряются детали, что приводит к более неясному поведению и ошибкам.
 
 Давайте начнем с рассмотрения примера. Здесь у нас есть StoreViewController, который состоит из 3 частей - представления заголовка, списка продуктов и представления действий. В настоящее время все эти три части настраиваются в методе viewDidLoad () контроллера вида, например так:*/

fileprivate class StoreViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        // Setup header view
        // ...

        // Setup product list
        // ...

        // Setup actions view
        //...
    }
}
/*Хотя приведенная выше реализация может начаться довольно просто, поскольку добавляются новые функции и пользовательский интерфейс становится все более сложным, эти методы имеют тенденцию довольно быстро расти. Скорее всего, если мы расширим эти ... выше, мы найдем сотни строк установочного кода, все в одном массивном методе, что делает вещи сложными для понимания и очень хрупкими - поскольку одно небольшое изменение может вызвать ошибку в другой части установочный код.
 
 Итак, как мы можем исправить вышесказанное? Один из способов - просто перенести настройку каждой части в свой собственный выделенный метод, предоставив нам три гораздо меньших метода настройки, каждый из которых гораздо проще рассуждать и поддерживать:*/

private extension StoreViewController {
    func setupHeaderView() {
    }

    func setupProductsView() {
    }

    func setupActionsView() {
    }
}

/*Другой мой любимый способ - использовать композицию контроллера представления и создать выделенный дочерний контроллер представления для каждой части нашего пользовательского интерфейса магазина:*/

fileprivate class ActionsViewController: UIViewController { }
fileprivate class HeaderViewController: UIViewController { }
fileprivate class ProductListViewController: UIViewController { }

fileprivate class StoreViewController1: UIViewController {
    private let header = HeaderViewController()
    private let productList = ProductListViewController()
    private let actions = ActionsViewController()

    override func viewDidLoad() {
        super.viewDidLoad()
        add(header, productList, actions)
    }
}


fileprivate extension UIViewController {
    func add(_ childs: UIViewController...) {
        for child in childs {
            addChild(child)
            view.addSubview(child.view)
            child.didMove(toParent: self)
        }
    }


    func add(_ child: UIViewController) {
        addChild(child)
        view.addSubview(child.view)
        child.didMove(toParent: self)
    }

    func remove() {
        guard parent != nil else {
            return
        }

        willMove(toParent: nil)
        view.removeFromSuperview()
        removeFromParent()
    }
}


// MARK: - Clear APIs
/*Другой распространенный источник сложности и путаницы - неясные API. Как я уже говорил в своем выступлении «Каждый является разработчиком API», создание четких и сфокусированных API между нашими типами может действительно помочь сделать основы кода намного проще для понимания - опять же, без добавления какой-либо дополнительной документации.
 
 Здесь у нас есть FriendsManager, который позволяет нам искать друзей текущего пользователя по имени:*/
fileprivate struct Friend { }

fileprivate class FriendsManager {
    private(set) var friends = [String: Friend]()
}

/*Изучив вышеупомянутое свойство, не очень ясно, что ключи в словаре друзей на самом деле являются именами. Это могут быть идентификаторы, имена пользователей или любая другая строка, насколько нам известно. Без документации вышеуказанный API становится сложным в использовании, и легко вызвать ошибку, используя его «неправильным способом».
 
 Вместо этого давайте сделаем API более понятным и сфокусированным - сделав частный словарь частным (это, в конце концов, подробности реализации того, как на самом деле хранятся друзья), и вместо этого предоставив специальный метод для поиска друга по имени, например этот:*/

fileprivate class FriendsManager1 {
    private var friendsByName = [String: Friend]()
    func friend(named name: String) -> Friend? {
        return friendsByName[name]
    }
}
/*Как вы можете видеть выше, мы также пользуемся возможностью, чтобы сделать имя свойства словаря более понятным. Несмотря на то, что он больше не является частью общедоступного API, присвоив ему имя friendsByName, всем, кто будет работать с этим кодом в будущем, станет ясно, что друзья действительно хранятся по имени и ничему другому.*/

// MARK: - Dedicated types
/*Разработка понятных API-интерфейсов, конечно, не только о том, как мы называем наши методы и как мы проводим грань между реализацией и общедоступным интерфейсом, но и о том, как мы структурируем наши типы и как мы используем систему типов и компилятор, чтобы убедиться, что наши код правильный.
 
 Как мы уже рассматривали в «Тип-безопасных идентификаторах в Swift», создание выделенных типов для таких вещей, как идентификаторы, действительно может помочь нам избежать ошибок и путаницы при работе со значениями на основе строк. То же самое можно сказать и о других типах, основанных на примитивах. Давайте рассмотрим пример, в котором мы используем Bool, чтобы указать, были ли успешно включены push-уведомления:*/

fileprivate protocol PushNotificationService {
    func enablePushNotification(then handler: @escaping (Bool) -> Void)
}
/*При первоначальном написании приведенного выше кода, может показаться сверхъестественным, что Bool, передаваемый обработчику, указывает, действительно ли включены push-уведомления, но это опять-таки может вызвать путаницу или заставить нас почувствовать необходимость в написании дополнительной документации.
 
 Вместо использования простого Bool, один из способов сделать описанный выше метод более явным - это использовать выделенный тип, например, перечисление, которое позволяет нам четко выразить, каков был результат операции:*/

fileprivate enum PushNotificationStatus {
    case enabled, disabled
}

fileprivate protocol PushNotificationService1 {
    typealias Handler = (PushNotificationStatus) -> Void
    func enablePushNotifications(then handler: @escaping Handler)
}

fileprivate func test(service: PushNotificationService1) {
    service.enablePushNotifications { status in
        switch status {
        case .disabled: break
        case .enabled: break
        }
    }
}

/*Другой пример использования системы типов для написания кода, который является более самодокументируемым, - это работа со значениями, которые имеют одинаковое базовое представление, но должны рассматриваться отдельно. Например, предположим, что наше приложение использует систему входа в систему на основе OAuth, и мы определили протокол для работы с авторизацией и полученными токенами доступа и обновления:*/

fileprivate protocol AuthorizationService {
    typealias Handler = (_ accessToken: String, _ refreshToken: String) -> Void

    func authorize(then handler: @escaping Handler)
}

/*Поскольку оба приведенных выше значения токена являются строками, нам нужно добавить метки (и, скорее всего, комментарий), чтобы понять, какое значение является каким. Опять же, это легко испортить, так как компилятор не выдаст нам никакого предупреждения, если мы случайно запомним порядок аргументов при использовании вышеуказанного API:
*/
fileprivate func testAuthorizationService(service: AuthorizationService) {
    service.authorize { accessToken, refreshToken in
        print("test")
    }
}

/*Давайте вместо этого получим систему типов, которая поможет нам. Объявив две простые структуры, мы можем создать выделенные типы для значений, представляющих каждый вид токена, что делает невозможным случайную передачу значения токена обновления в качестве токена доступа:*/

fileprivate struct AccessToken {
    let string: String
}

fileprivate struct RefreshToken {
    let string: String
}

fileprivate protocol AuthorizationService1 {
    typealias Handler = (AccessToken, RefreshToken) -> Void
    func authorize(then handler: @escaping Handler)
}

// MARK: - Type aliases
/*Не всегда практично создавать новые типы для всего, и иногда это может фактически сделать наш код более сложным. Тем не менее, мы все еще можем использовать систему типов, чтобы сделать наш код более самодокументируемым, и в таких ситуациях использование псевдонимов типов может быть отличным вариантом.
 
 Например, допустим, у нас есть тип, который мы используем для представления файлов в нашем приложении:*/
fileprivate struct File {
    let name: String
    let size: Int
}

/*Глядя на приведенную выше декларацию, немного неясно, к какому размеру относится. Мы говорим байты, килобайты, мегабайты? Как насчет количества символов, если мы имеем дело с текстовыми файлами? Хотя мы, вероятно, сможем выяснить ответ, покопавшись в реализации, если что-то не очевидно на уровне декларации, это обычно плохой признак.
 
 Основываясь на некоторых из методов, которые мы уже рассмотрели, мы можем использовать несколько различных подходов:
 
 Создайте выделенный тип Size, который может иметь свойство numberOfBytes.
 Переименовать размер в numberOfBytes
 Добавьте комментарий, который говорит, что это измеряется в байтах.
 Все вышеприведенные решения верны, но, возможно, самое простое решение - использовать typealias, чтобы было ясно, что мы имеем дело с байтами в качестве нашей единицы измерения:*/

fileprivate struct File1 {
    typealias ByteCount = Int

    let name: String
    let size: ByteCount
}

/*Тем не менее, использование псевдонимов типов таким способом - это то, с чем мы могли бы легко обойтись - в результате получается код, противоположный простому и понятному, например:*/
fileprivate struct User {
    typealias Name = String
    typealias Age = Int
    typealias CityName = String

    let name: Name
    let age: Age
    let cityName: CityName
}

/*Как всегда, баланс является ключевым. При экономном использовании (особенно для таких вещей, как единицы измерения) псевдонимы типов могут быть довольно хорошим решением. Вот еще один пример, в котором мы используем псевдонимы типов, чтобы определить наши единицы для силы тяжести и силы ветра для уровня в игре, при этом все еще используя примитивы для таких свойств, как имя и индекс:
*/

fileprivate struct Level1 {
    typealias Newtons = CGFloat
    typealias MetersPerSecond = CGFloat

    let index: Int
    let name: String
    var gravity: Newtons
    var windStrength: MetersPerSecond
}
