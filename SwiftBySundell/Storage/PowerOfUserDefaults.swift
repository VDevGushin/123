//
//  PowerOfUserDefaults.swift
//  SwiftBySundell
//
//  Created by Vladislav Gushin on 04/03/2019.
//  Copyright © 2019 Vladislav Gushin. All rights reserved.
//

import Foundation
/*Доступный с самого первого выпуска iOS SDK, API UserDefaults может на первый взгляд казаться очень простым и несколько ограниченным.
 Хотя он предоставляет простой в использовании способ сохранения и хранения постоянных значений, способ сохранения этих значений в одном файле plist может сделать его непрактичным для больших наборов данных - в результате многие разработчики отклонят его в пользу более полнофункциональных баз данных. или какая-то форма нестандартного решения.
 
 Однако внешний вид может быть обманчивым, и оказывается, что мощь UserDefaults выходит далеко за рамки простого хранения и загрузки основных типов значений.
 На этой неделе давайте посмотрим, откуда взялись эти возможности, и как мы можем соответствующим образом использовать их в приложениях, которые мы создаем.*/

// MARK: - Database or not?
/*Очень часто UserDefaults позиционируется как альтернатива решению для базы данных - например, CoreData или SQLite. Несмотря на то, что API по умолчанию пользователя может выступать в качестве базы данных, его основной сценарий использования в большей степени сосредоточен вокруг значений, которые относятся к предпочтениям пользователя - которые, если присмотреться к его различным функциональным возможностям и тому, как он интегрируется с системой, делает его гораздо менее похожим на ограниченную базу данных - и больше похож на сфокусированный API, который действительно хорошо справляется с основным набором вещей.
 
 Давайте начнем с примера, в котором мы создаем ThemeController, который будет отвечать за отслеживание текущей темы, которую наше приложение будет использовать для визуализации своего пользовательского интерфейса. Поскольку это то, что пользователи могут выбирать сами, имеет смысл рассматривать его как предпочтение пользователя и сохранять его значение в UserDefaults.
 
 Для этого мы вставим экземпляр в ThemeController (который по умолчанию будет использовать стандартный набор значений по умолчанию) и используем его для сохранения и загрузки значений Theme - например, так:*/
fileprivate enum Theme: String {
    case light
    case dark
    case black
}

fileprivate class ThemeController {
    private(set) lazy var currentTheme = loadTheme()
    private let defaults: UserDefaults
    private let defaultsKey = "theme"

    init(defaults: UserDefaults = .standard) {
        self.defaults = defaults
    }

    func changeTheme(to theme: Theme) {
        currentTheme = theme
        defaults.setValue(theme.rawValue, forKey: defaultsKey)
    }

    private func loadTheme() -> Theme {
        let rawValue = defaults.string(forKey: defaultsKey)
        return rawValue.flatMap(Theme.init) ?? .light
    }
}
/*Вышеприведенная реализация может показаться простой, но то, как мы будем использовать UserDefaults для этого типа настроек, вскоре откроет довольно много интересных функций - как для наших пользователей, так и для нас как разработчиков.
*/

// MARK: - Sharing data within an app group
/*Первое, что позволит нам использовать UserDefaults, - это легко обмениваться данными между несколькими приложениями и расширениями приложений. Например, предположим, что мы либо поставляем два приложения (если мы создаем службу совместного использования поездок, это может быть одно приложение для водителей и одно приложение для клиентов), либо что одно разрабатываемое нами приложение также включает расширение, которое представляет некоторую форму пользовательского интерфейса.
 
 Чтобы позволить нашим пользователям выбирать выбранную тему только один раз, а затем распространять это значение по всему нашему пользовательскому интерфейсу, мы можем установить набор по умолчанию. Например, если мы создаем два приложения, которые находятся в одной и той же группе приложений, мы могли бы создать экземпляр UserDefaults с именем набора, который соответствует идентификатору нашей группы приложений:*/

fileprivate extension UserDefaults {
    static var shared1: UserDefaults {
        return UserDefaults(suiteName: "group.johnsundell.app")!
    }
}
/*Другой вариант - просто добавить наш набор групп приложений к стандартным настройкам по умолчанию - создать объединенный экземпляр UserDefaults, например так:
*/
fileprivate extension UserDefaults {
    static var shared2: UserDefaults {
        let combined = UserDefaults.standard
        combined.addSuite(named: "group.johnsundell.app")
        return combined
    }
}
/*Разница между двумя вышеупомянутыми параметрами заключается в том, что при создании экземпляра UserDefaults на основе стандартного набора значений по умолчанию (как мы делаем в последнем примере) значения в стандартных значениях по умолчанию всегда будут переопределять значения из нашего общего набора. Это может быть полезно (если мы хотим включить локальные переопределения для каждого приложения), но также может усложнить распространение общих настроек.*/
fileprivate extension ThemeController {
    convenience init(custom: UserDefaults = .shared1) {
        self.init(defaults: custom)
    }
}
/*Прелесть этого аспекта UserDefaults заключается в том, что он все еще предлагает нам 100% синхронный API, даже если изменения распространяются на несколько приложений или расширений асинхронно в фоновом режиме. Это позволяет нашему локальному коду немедленно продолжить работу после обновления значения, не жертвуя при этом производительностью, ожидая обновления всех экземпляров.
 
 Значения, сохраненные таким образом, сохраняются до тех пор, пока все приложения в группе приложений не будут удалены с устройства пользователя.*/

// MARK: - Overriding values at launch
/*Как мы уже рассматривали в разделе «Запустить аргументы в Swift», приложение, принимающее аргументы при запуске, может стать отличным способом настройки его как для ручного, так и для автоматического тестирования, а UserDefaults автоматически анализирует любые аргументы, передаваемые в приложение, и использует эти значения в качестве локальных переопределений.
 
 Это позволяет нам использовать редактор схем Xcode (Product> Scheme> Edit Scheme ...), чтобы легко настроить, какую тему будет использовать наше приложение, добавив аргумент -theme с именем одной из наших тем, но также позволяет нам сделать то же самое в тесте пользовательского интерфейса.
 
 Например, предположим, что мы хотим написать тест, который проверяет, правильно ли в окне выбора настроек нашего экрана отображается текущая тема в том виде, в котором она была выбрана. Чтобы сделать это очень предсказуемым образом, все, что нам нужно сделать, это передать тему в качестве аргумента запуска в XCUIApplication, а затем убедиться, что переданная тема действительно помечена как выбранная в пользовательском интерфейсе - с помощью идентификаторов доступности, например, так: :*/
