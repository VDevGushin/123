//
//  InlineTypesAndFunctions .swift
//  SwiftBySundell
//
//  Created by Vladislav Gushin on 18/02/2019.
//  Copyright © 2019 Vladislav Gushin. All rights reserved.
//

import UIKit
/*Разделение проблем и разделение - это невероятно важные вещи, которые нужно делать, когда речь идет о написании кода, у которого гораздо больше шансов выдержать испытание временем, но слишком частое разделение кода часто может иметь совершенно противоположный эффект. Даже если технически приложение или система могут иметь надежную архитектуру, которая соответствует всем правилам хорошего проектирования системы, наш код все равно может испытывать трудности при навигации.
 
 Один из способов уменьшить это, сохраняя при этом твердую общую структуру в нашей кодовой базе, состоит в том, чтобы встроить функциональность всякий раз, когда два фрагмента кода тесно связаны между собой. На этой неделе давайте посмотрим, как это можно сделать с помощью встроенных типов и функций, и как - при тактическом развертывании в правильных ситуациях - это может сделать наш код немного более понятным.º*/

// MARK: - Container types
/*Давайте начнем с примера. При работе с каким-либо веб-API - будь то что-то, что мы сами контролируем, или внешним сервисом, на который мы полагаемся - очень часто возникает несоответствие между форматом данных, возвращаемых API, и структурой нашего Свифт код.
 Допустим, мы хотим использовать Codable для декодирования вышеуказанных данных, но нас интересует только фактический массив результатов, а не корневой объект. Это потребовало бы от нас создания некоторой формы типа «Контейнер», в которой мы расшифровываем наш ответ веб-API, а затем мы можем извлечь наши результаты из этого экземпляра:*/

fileprivate struct SearchResult: Codable { }

fileprivate struct Container: Codable {
    var results: [SearchResult]
}

/*Но вопрос в том, куда поставить вышеуказанный вид шрифта? Хотя мы могли бы сделать его типом верхнего уровня и поместить его в свой собственный файл Swift, поскольку он когда-либо использовался только для облегчения JSON-декодирования наших результатов поиска - не будет ли проще просто поместить его прямо рядом с этим кодом?
 
 Это именно то, что нам позволяют делать встроенные типы - поскольку Swift поддерживает определения типов не только на верхнем уровне нашей программы, но также внутри других типов и даже внутри отдельных функций - например, так:*/

fileprivate struct SearchResultsLoader {
    func decodeResults(from data: Data) throws -> [SearchResult] {
        struct Container: Codable {
            var results: [SearchResult]
        }
        let decoder = JSONDecoder()
        let container = try decoder.decode(Container.self, from: data)
        return container.results
    }
}

// MARK: - Simple mocks
/*Другая ситуация, в которой встроенные типы могут пригодиться при написании модульных тестов. Особенно при тестировании некоторого нашего более сложного кода, мы обычно заканчиваем тем или иным способом насмешек - и при этом, как правило, хорошей идеей является попытка сделать эти насмешки как можно более простыми.
 
 Допустим, что наше приложение использует метафору Action для обновления нескольких независимых действий через регулярные промежутки времени через протокол, который выглядит следующим образом:*/

fileprivate enum UpdateOutcome {
    case finished
    case cancelled
}

fileprivate protocol Action: AnyObject {
    func update(at timestamp: TimeInterval) -> UpdateOutcome
}

/*Когда вызывается вышеуказанный метод обновления, каждое действие возвращает UpdateOutcome, который представляет собой перечисление, содержащее такие случаи, как завершено, отменено и т. Д. Этот результат затем используется ActionController, чтобы определить, должно ли действие продолжать получать обновления или его следует удалить.
 
 Теперь предположим, что мы хотели бы написать модульный тест, который проверяет, правильно ли наш ActionController удаляет действие, которое вернуло отмененный результат при обновлении. Чтобы сделать это, мы будем издеваться над нашим протоколом Action, чтобы создать действие, предназначенное для отмены самого первого обновления, например:
*/

fileprivate class CancelingActionMock: Action {
    func update(at timestamp: TimeInterval) -> UpdateOutcome {
        return .cancelled
    }
}
/*Как и в нашем примере с контейнером с результатами поиска, так как приведенный выше макет очень специфичен для модульного теста, который мы собираемся написать (учитывая, что он всегда готов отменить себя), возможно, наиболее подходящим местом для его размещения является встроенный в нашем тесте. Таким образом, мы могли бы просто назвать его Mock, и весь наш тестовый код содержался бы в одном методе:*/
fileprivate class ActionControllerTests {
    func testCancelledActionRemoved() {
        class Mock: Action {
            func update(at timestamp: TimeInterval) -> UpdateOutcome {
                return .cancelled
            }
        }
        let action = Mock()
        print("Work with mock")
        dump(action)
    }
}

/*Одной альтернативой вышеупомянутому было бы вместо этого сделать наш макет немного более общим и более простым для повторного использования - например, присвоив ему имя ActionMock и разрешив его инициализацию с любым возвращаемым UpdateOutcome, что позволило бы сделать его верхним уровнем общий тип.
 
 Хотя это также вполне допустимый подход (и, возможно, более уместный в случаях, когда один и тот же протокол необходимо подвергать повторной проверке несколько раз), он немного усложняется за счет введения дополнительных типов, о которых мы должны знать при чтении и записи. наши тесты. Хранение встроенных вещей как бы «заставляет» нас держать насмешки запрограммированными и простыми, что обычно полезно для удобства обслуживания и ясности.*/

// MARK: - Self-executing closures

/*Иногда не только типы могут извлекать выгоду от встраивания в контекст, в котором они используются - то же самое можно сказать и о логике, которая вычисляет данные или состояние программы.
 
 Например, предположим, что мы пишем скрипт Swift, чтобы иметь возможность быстро проверить, сколько открытых репозиториев имеет данный пользователь GitHub. Наш скрипт получит имя пользователя, которое мы хотим просмотреть через аргумент командной строки, а затем создаст URL-адрес веб-API GitHub, используя это имя, и, наконец, выполнит сетевой запрос и проанализирует результат.
 
 В настоящее время мы структурировали наш скрипт с использованием отдельных функций, каждая из которых выполняет одну из указанных выше операций, например:*/

fileprivate struct GitHubWorker {
    func extractNameFromArguments() -> String { return "" }
    func constructURL(for name: String) -> URL { return URL(string: name)! }
    func loadUser(from url: URL) -> Any? { return nil }

    func execute() {
        let name = self.extractNameFromArguments()
        let url = self.constructURL(for: name)
        let user = self.loadUser(from: url)
        dump(user)
    }
}

/*Вышеприведенное выглядит действительно аккуратно, но если мы начнем изучать базовые функции, то окажется, что для каждого шага не требуется много логики. Поэтому вместо того, чтобы постоянно перемещаться по функциям во время навигации по нашему коду, мы могли бы вместо этого трансформировать эти функции в самореализующиеся замыкания.
 
 Как мы уже рассматривали в разделе «Использование ленивых свойств в Swift», самозапускающееся замыкание - это просто обычное замыкание, которое сразу вызывает себя при определении - и может обеспечить отличный способ инкапсулировать настройку объекта или значения - как это :*/
fileprivate struct ClosureExample {
    let redButton: UIButton = {
        let button = UIButton(frame: .zero)
        button.backgroundColor = .red
        return button
    }()
}

/*Использование описанной выше техники для нашего скрипта GitHub позволило бы нам достичь того же уровня инкапсуляции, что и раньше, но со всей нашей логикой, теперь встроенной в соответствии с основным потоком скрипта - давая нам очень хороший обзор всех наших операций и их реализации:
*/
fileprivate enum GitHubWorkerError: Error {
    case noName
    case invalidName
}

fileprivate struct GitHubUser: Codable { }

fileprivate class GitHubWorker1 {
    lazy var name: String? = try? {
        let arguments = [String]()
        guard arguments.count > 1 else {
            throw GitHubWorkerError.noName
        }
        return arguments[1]
    }()

    lazy var url: URL? = try? {
        guard let name = name else { throw GitHubWorkerError.noName }

        let urlString = "https://api.github.com/users/" + name

        guard let url = URL(string: urlString) else {
            throw GitHubWorkerError.invalidName
        }

        return url
    }()

    lazy var user: GitHubUser? = try? {
        guard let url = url else { throw GitHubWorkerError.noName }
        let data = try Data(contentsOf: url)
        let decoder = JSONDecoder()
        return try decoder.decode(GitHubUser.self, from: data)
    }()
}

// MARK: - Inline function definitions
/*Наконец, давайте посмотрим, как могут быть встроены даже правильные объявления функций - и как это может быть действительно полезным, особенно при работе с рекурсивным кодом.
 
 Допустим, мы создаем приложение для создания заметок и что одна из наших самых полезных функций - это то, что наше приложение позволяет пользователю быстро открывать первую заметку, соответствующую заданному поисковому запросу. Эта функция реализована с помощью класса NoteFinder, который на данный момент выглядит следующим образом:*/

fileprivate struct File {
    func read(then handler: (Any?) -> Void) {
        handler(nil)
    }
}

fileprivate struct Note {
}

fileprivate struct NoteFinder {
    private var files: [File]
    private var findIndex = 0

    mutating func findFirstNote(matching query: String,
                                then handler: @escaping (Note?) -> Void) {
        findIndex = 0
        performFind(withQuery: query, handler: handler)
    }

    private mutating func performFind(withQuery query: String,
                                      handler: @escaping (Note?) -> Void) {
        guard findIndex < files.count else {
            return handler(nil)
        }

        let file = files[findIndex]
        findIndex += 1

        file.read { content in
            handler(nil)
        }
    }
}

/*Есть две основные проблемы с вышеупомянутой реализацией. Во-первых, нам нужно передать и запрос, и обработчик завершения во вторую функцию, которая кажется немного ненужной, учитывая, что первоначальная функция findFirstNote на самом деле мало что делает. Второе, и, возможно, даже более важное, заключается в том, что наша функция поиска заметок в настоящее время находится в состоянии.
 
 Поскольку мы обнуляем значение findIndex на 0 каждый раз, когда вызываем findFirstNote, мы могли бы легко получить некоторые довольно неприятные ошибки, если бы нам когда-нибудь пришлось выполнять два сеанса поиска одновременно. Одним из способов решения этой проблемы было бы также передать текущий индекс в executeFind, но это только добавило бы к первой проблеме необходимости передачи большого количества данных во вторую функцию.
 
 Вместо этого, давайте снова используем встраивание - на этот раз, чтобы фактически поместить всю нашу функцию executeFind в строку внутри findFirstNote. Таким образом, мы можем одновременно дать ему более простое имя и подпись (теперь мы просто назовем его matchNext), и поскольку встроенные функции могут как захватывать состояние - как замыкания - так и рекурсивно вызывать себя, мы получим гораздо более простую реализация без утечки любого состояния:*/

fileprivate struct NoteFinder1 {
    private var files: [File]

    func findFirstNote(matching query: String,
                       then handler: @escaping (Note?) -> Void) {
        // These local variables can be captured by our inline
        // function, removing the need for the class itself to
        // to manage any state local to this function.
        var index = 0
        let files = self.files

        func matchNext() {
            guard index < files.count else {
                return handler(nil)
            }

            let file = files[index]
            index += 1

            file.read { content in
                handler(nil)
            }
        }

        matchNext()
    }
}
