//
//  SpecializingProtocols.swift
//  SwiftBySundell
//
//  Created by Vladislav Gushin on 07/02/2019.
//  Copyright © 2019 Vladislav Gushin. All rights reserved.
//

import UIKit
/*Протоколы по-прежнему являются неотъемлемой частью Swift - как с точки зрения того, как разработан сам язык, так и с точки зрения структуры стандартной библиотеки. Поэтому неудивительно, что практически каждый выпуск Swift добавляет новые функции, связанные с протоколами, что делает их еще более гибкими и мощными.
 
 Особенно при разработке абстракций в приложении или системе протоколы предоставляют способ четко отделить различные типы друг от друга и настроить более четко определенные API-интерфейсы, что обычно упрощает все - от тестирования до рефакторинга.
 
 На этой неделе давайте посмотрим, как мы можем использовать протоколы для создания нескольких уровней абстракции, и опробуем несколько различных методов, которые позволят нам начать с более общего протокола, который мы затем все больше специализируем, чтобы стать более и более специфичным для каждого из них. вариант использования.
*/
// MARK: - Наследование
/*
Как и классы, один протокол может наследовать требования другого протокола, что позволяет формировать иерархии с дополнительной гибкостью, которую (в отличие от классов) протоколы могут наследовать от нескольких родителей. Это особенно полезно, когда один протокол чаще всего требует свойств или методов из родительского протокола при использовании.

Примером этого является стандартная библиотека Hashable, которая наследуется от Equatable. Это имеет огромное значение, поскольку, когда используется хеш-значение - например, когда значение вставляется в набор - за каждой успешной проверкой хеш-значения также следует проверка на равенство.

Давайте рассмотрим пример, когда этот шаблон может быть полезен и в нашем собственном коде. Допустим, мы создаем приложение, которое поддерживает несколько типов пользователей - зарегистрированных пользователей, анонимных пользователей, которые еще не создали учетную запись, и администраторов. Чтобы иметь возможность иметь отдельные реализации для каждого типа пользователей, но при этом делить код между ними, мы создаем пользовательский протокол, который определяет основные требования для каждого типа пользователей - например, так:
*/

fileprivate protocol User {
    var id: UUID { get set }
    var name: String { get set }
}
/*Поскольку каждый из наших пользовательских типов уже имеет два вышеупомянутых свойства, мы можем легко заставить их соответствовать нашему пользовательскому протоколу, используя серию пустых расширений:*/
fileprivate struct AnonymousUser {
    var id: UUID
    var name: String
}

extension AnonymousUser: User { }

fileprivate struct AccessToken { }
fileprivate enum Result<T> {
    case success(T)
    case error(Error)
}

fileprivate protocol AuthenticatedUser: User {
    var accessToken: AccessToken { get }
}

/*Теперь мы можем использовать наш новый протокол AuthenticatedUser в тех случаях, когда нам требуется зарегистрированный пользователь, например, при создании запроса на загрузку данных из конечной точки сервера, требующей аутентификации:*/
fileprivate class DataLoader {
    func load(from url: String, user: AuthenticatedUser, then: @escaping (Result<Data>) -> Void) {

    }

    private func makeRequest(from url: String) -> URLRequest {
        return URLRequest(url: URL(string: url)!)
    }
}

// MARK: - Cпециализация
/*Далее, давайте посмотрим, как мы можем дополнительно специализировать дочерние протоколы при наследовании от протокола, который использует связанные типы. Допустим, мы создаем управляемую компонентом систему пользовательского интерфейса для приложения, в которой компонент может быть реализован различными способами - например, с помощью UIView, UIViewController или CALayer. Чтобы обеспечить такую степень гибкости, мы начнем с очень общего протокола, называемого Компонентом, который позволяет каждому компоненту решать, к какому контейнеру он может быть добавлен:*/
fileprivate protocol Component {
    associatedtype Container
    var container: Container { get set }
}

fileprivate protocol ViewComponent: Component where Container: UIView {
    associatedtype View: UIView
    var view: View { get set }
}

/*В качестве альтернативы выполнению вышеизложенного можно использовать условие where каждый раз, когда мы хотим иметь дело с компонентами на основе UIView, но настройка для него специализированного протокола может помочь нам избавиться от большого количества шаблонов и сделать вещи более упорядоченными.
 
 Теперь, когда у нас есть гарантия времени компиляции, что все компоненты, соответствующие ViewComponent, имеют представление, и что их тип контейнера также является представлением, мы можем использовать расширения протокола, чтобы добавить реализации по умолчанию некоторых требований базового протокола - например, так:
*/
fileprivate extension ViewComponent {
    func add(to container: Container) {
        container.addSubview(self.view)
    }
}

// MARK: Композиция
/*Наконец, давайте посмотрим, как мы можем специализировать протоколы с помощью композиции. Допустим, у нас есть протокол Operation, который мы используем для реализации всевозможных асинхронных операций. Поскольку мы используем единый протокол для всех операций, в настоящее время он требует от нас реализации нескольких различных методов для каждой из них:*/
fileprivate protocol Operation {
    associatedtype Input
    associatedtype Output

    func prepare()
    func cancel()

    func perform(with input: Input, than handler: @escaping (Output) -> Void)
}

/*Настройка протоколов большего размера, как мы делали выше, на самом деле не является неправильной, но может привести к некоторым избыточным реализациям, если у нас - например - есть определенные операции, которые не могут быть отменены или действительно не требуется никакой специальной подготовки (так как мы все еще требуется для реализации этих методов протокола).
 
 Это то, что мы можем решить с помощью композиции. Давайте еще раз почерпнем вдохновение из стандартной библиотеки - на этот раз, посмотрев на тип Codable, который на самом деле является просто typealias, который составляет два протокола - Decodable и Encodable:*/
//typealias Codable = Decodable & Encodable
/*Прелесть вышеупомянутого подхода заключается в том, что типы могут свободно соответствовать либо Decodable, либо Encodable, и мы можем писать функции, которые имеют дело только с декодированием или кодированием, но при этом получают удобство, позволяя ссылаться на оба с использованием одного типа. ,
 
 Используя ту же технику, мы можем разложить наш предыдущий протокол Operation на три отдельных, каждый из которых посвящен одной задаче:*/

fileprivate protocol Prepare {
    func prepare()
}

fileprivate protocol Cancellable {
    func cancel()
}

fileprivate protocol Performable {
    associatedtype Input
    associatedtype Output

    func perform(with input: Input,
                 then handler: @escaping (Output) -> Void)
}

fileprivate typealias Operaton = Performable & Prepare & Cancellable

fileprivate extension Sequence where Element == Cancellable {
    func cancelAll() {
        forEach { $0.cancel() }
    }
}
